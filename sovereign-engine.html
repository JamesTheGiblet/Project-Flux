<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sovereign Engine - Hackable Game Framework</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            color: #00ff88;
            overflow: hidden;
            height: 100vh;
        }
        .container { display: flex; height: 100vh; }
        .game-area {
            flex: 1;
            position: relative;
            background: #000;
            border: 2px solid #00ff88;
            margin: 10px;
        }
        #gameCanvas {
            width: 100%;
            height: 100%;
            background: #0a0a0a;
        }
        .top-right-ui {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 10px;
            z-index: 100;
        }
        #activePowerUpsContainer {
            display: flex;
            gap: 8px;
        }
        .powerup-icon {
            background: rgba(0,0,0,0.7);
            border: 1px solid #fff;
            color: #fff;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
        }
        .mod-panel {
            width: 300px;
            background: rgba(16, 33, 62, 0.9);
            border-left: 2px solid #00ff88;
            padding: 15px;
            overflow-y: auto;
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
        }
        .header {
            text-align: center;
            padding: 15px;
            border-bottom: 1px solid #00ff88;
            margin-bottom: 15px;
        }
        .header h1 {
            font-size: 20px;
            color: #00ff88;
            text-shadow: 0 0 10px #00ff88;
        }
        .header p {
            color: #888;
            font-size: 10px;
            margin-top: 3px;
        }
        .mod-section {
            margin-bottom: 20px;
        }
        .mod-section h3 {
            color: #ff6b00;
            border-bottom: 1px solid #ff6b00;
            padding-bottom: 3px;
            margin-bottom: 8px;
            font-size: 12px;
        }
        .code-editor {
            background: #1a1a1a;
            border: 1px solid #333;
            color: #00ff88;
            font-family: 'Courier New', monospace;
            font-size: 10px;
            width: 100%;
            height: 100px;
            resize: vertical;
            padding: 8px;
            margin-bottom: 8px;
        }
        .apply-btn {
            background: #ff6b00;
            color: #000;
            border: none;
            padding: 6px 12px;
            border-radius: 3px;
            cursor: pointer;
            font-weight: bold;
            font-size: 11px;
            width: 100%;
            transition: all 0.3s ease;
        }
        .save-preset-area {
            display: flex;
            margin-top: 8px;
        }
        .preset-name-input {
            flex-grow: 1;
            background: #1a1a1a;
            border: 1px solid #333;
            color: #00ff88;
            padding: 6px;
            font-family: 'Courier New', monospace;
            font-size: 10px;
            margin-right: 5px;
        }
        .save-btn {
            background: #005588;
            color: #fff;
            border: none;
            padding: 6px 10px;
            cursor: pointer;
        }
        .execute-btn {
            background: #00ffff;
            color: #000;
            border: none;
            padding: 6px 12px;
            border-radius: 3px;
            cursor: pointer;
            font-weight: bold;
            font-size: 11px;
            width: 100%;
            transition: all 0.3s ease;
        }
        .mod-panel select {
            width: 100%;
            background: #1a1a1a;
            border: 1px solid #333;
            color: #00ff88;
            padding: 5px;
            margin-bottom: 8px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            -webkit-appearance: none;
            appearance: none;
            /* Add custom arrow to make it look like a dropdown */
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%2300FF88%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22/%3E%3C/svg%3E');
            background-repeat: no-repeat;
            background-position: right 10px top 50%;
            background-size: 10px;
            padding-right: 30px; /* Make space for the arrow */
        }
        .apply-btn:hover {
            background: #ff8533;
            box-shadow: 0 0 8px rgba(255, 107, 0, 0.5);
        }
        .execute-btn:hover {
            background: #88ffff;
            box-shadow: 0 0 8px rgba(0, 255, 255, 0.7);
        }
        .stats {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px;
            border: 1px solid #00ff88;
            border-radius: 3px;
            color: #00ff88;
            font-size: 11px;
            -webkit-backdrop-filter: blur(5px);
            backdrop-filter: blur(5px);
            z-index: 100;
        }
        .manifesto {
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #ff6b00;
            border-radius: 3px;
            padding: 10px;
            margin-bottom: 15px;
            font-size: 9px;
            line-height: 1.3;
        }
        .manifesto-title {
            color: #ff6b00;
            font-weight: bold;
            margin-bottom: 5px;
        }
        .tutorial-summary {
            color: #00ffff;
            border-bottom: 1px solid #00ffff;
            padding-bottom: 3px;
            margin-bottom: 8px;
            font-size: 12px;
            cursor: pointer;
            font-weight: bold;
            list-style: none; /* Hide default arrow */
        }
        .tutorial-summary::-webkit-details-marker {
            display: none; /* Hide default arrow for Chrome */
        }
        .tutorial-summary:before {
            content: '► ';
            font-size: 10px;
        }
        details[open] > .tutorial-summary:before {
            content: '▼ ';
        }
        .tutorial-content {
            font-size: 10px;
            line-height: 1.4;
            color: #ccc;
            padding-left: 5px;
            border-left: 1px solid #333;
            margin-top: 10px;
        }
        .tutorial-content h4 {
            color: #ff6b00;
            margin-top: 10px;
            margin-bottom: 5px;
        }
        .tutorial-content p {
            margin-bottom: 5px;
        }
        .tutorial-content code {
            background: #1a1a1a;
            color: #00ff88;
            padding: 1px 4px;
            border-radius: 2px;
            font-size: 9px;
        }
        .tutorial-content pre {
            background: #1a1a1a;
            border: 1px solid #333;
            padding: 5px;
            margin: 5px 0 10px 0;
            border-radius: 3px;
            white-space: pre-wrap;
        }
        .tutorial-content pre code {
            padding: 0;
            background: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="game-area">
            <canvas id="gameCanvas"></canvas>
            <div class="stats" id="gameStats">
                FPS: <span id="fps">60</span><br>
                Objects: <span id="objectCount">0</span><br>
                Score: <span id="score">0</span>
            </div>
            <div class="top-right-ui">
                <div id="activePowerUpsContainer">
                    <!-- Active power-up icons will be dynamically added here -->
                </div>
            </div>
        </div>
       
        <div class="mod-panel">
            <div class="header">
                <h1>SOVEREIGN ENGINE</h1>
                <p>Hackable. Modular. Yours.</p>
            </div>

            <div class="manifesto">
                <div class="manifesto-title">⚡ BUILDER'S MANIFESTO</div>
                Every pixel is hackable. Every rule is rewritable. This is sovereign software—no gatekeepers, just pure creative freedom.
            </div>

            <div class="mod-section">
                <details>
                    <summary class="tutorial-summary">📖 HOW TO HACK</summary>
                    <div class="tutorial-content">
                        <p>Welcome, builder! This engine is yours to command. Here's how to write your own mods.</p>
                        
                        <h4>🔫 Weapon Mods</h4>
                        <p>Define how your weapon fires using the function: <code>function shoot(player, target, engine)</code>. To fire a bullet, add an object to <code>engine.projectiles</code>.</p>
                        <pre><code>// Example: A slow, powerful shot
engine.projectiles.push({
  x: player.x, y: player.y,
  vx: (target.x - player.x) / 5,
  vy: (target.y - player.y) / 5,
  size: 8, color: '#ff00ff',
  life: 3, // Seconds until it disappears
  damage: 50
});</code></pre>

                        <h4>🎮 Rule Mods</h4>
                        <p>Control the game's logic every frame using: <code>function update(engine, dt)</code>. Use <code>dt</code> (delta-time) for smooth, frame-rate independent logic.</p>
                        <pre><code>// Spawn a special enemy every 5 seconds
if (engine.gameTime % 5 < dt) {
  engine.spawnEnemy({
    health: 100, size: 15,
    color: '#00ffff',
    ai_type: 'linear' // or 'chase'
  });
}</code></pre>

                        <h4>🧍 Player Mods</h4>
                        <p>Change your character's stats using: <code>function modifyPlayer(player)</code>. This is run once when you click "Apply".</p>
                        <pre><code>// Make the player super fast!
player.speed = 500;
player.color = '#ffff00';</code></pre>

                        <h4>💾 Saving & Hacking</h4>
                        <p>Use the <b>Save</b> button to store your creations. They'll be here next time you play! The <b>Hack The System</b> panel gives you direct, raw access to the entire 'game' object. Use with caution... or don't!</p>
                    </div>
                </details>
            </div>

            <div class="mod-section">
                <h3>🔫 WEAPON MOD</h3>
                <select id="weaponSelector" title="Select weapon mod preset" onchange="selectPreset('weapon', this.value)"></select>
                <textarea class="code-editor" id="weaponCode" placeholder="Write or modify weapon code here..."></textarea>
                <button class="apply-btn" onclick="applyMod('weapon')">Apply Weapon</button>
                <div class="save-preset-area">
                    <input type="text" class="preset-name-input" id="weaponPresetName" placeholder="Save as new preset...">
                    <button class="save-btn" onclick="savePreset('weapon')">💾 Save</button>
                </div>
            </div>

            <div class="mod-section">
                <h3>🎮 RULES MOD</h3>
                <select id="ruleSelector" title="Select rule mod preset" onchange="selectPreset('rule', this.value)"></select>
                <textarea class="code-editor" id="ruleCode" placeholder="Write or modify game rules here..."></textarea>
                <button class="apply-btn" onclick="applyMod('rule')">Apply Rules</button>
                 <div class="save-preset-area">
                    <input type="text" class="preset-name-input" id="rulePresetName" placeholder="Save as new preset...">
                    <button class="save-btn" onclick="savePreset('rule')">💾 Save</button>
                </div>
            </div>

            <div class="mod-section">
                <h3>🧍 PLAYER MOD</h3>
                <select id="playerSelector" title="Select player mod preset" onchange="selectPreset('player', this.value)"></select>
                <textarea class="code-editor" id="playerCode" placeholder="Write or modify player properties here..."></textarea>
                <button class="apply-btn" onclick="applyMod('player')">Apply Player</button>
                 <div class="save-preset-area">
                    <input type="text" class="preset-name-input" id="playerPresetName" placeholder="Save as new preset...">
                    <button class="save-btn" onclick="savePreset('player')">💾 Save</button>
                </div>
            </div>

            <div class="mod-section">
                <h3>💻 HACK THE SYSTEM</h3>
                <textarea class="code-editor" id="hackCode" placeholder="/* DANGER ZONE */
// Code here has direct access to the 'game' object.
// Examples:
// player.health = 999;
// game.score += 1000;"></textarea>
                <button class="execute-btn" onclick="executeHack()">⚡ Execute</button>
            </div>
        </div>
    </div>

    <script src="weapons.js"></script>
    <script src="rules.js"></script>
    <script src="player.js"></script>
    <script src="power-ups.js"></script>
    <script>
        class SovereignEngine {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.resizeCanvas();
                
                this.player = { x: 400, y: 300, vx: 0, vy: 0, health: 100, size: 8, color: '#00ff88', speed: 200, lastMoveDir: { x: 0, y: -1 } };
                this.enemies = [];
                this.projectiles = [];
                this.particles = [];
                
                this.isMouseDown = false;
                this.lastShotTime = 0;
                this.keys = {};
                this.mousePos = { x: 0, y: 0 };
                this.gameTime = 0;
                this.score = 0;
                this.frameCount = 0;
                this.lastFpsUpdate = 0;
                this.enemySpeed = 80;
                this.lastDifficulty = 0;
                
                this.weaponShoot = this.defaultShoot;
                this.rulesUpdate = () => {}; // Will be set by applyMod on load
                
                this.setupEvents();
                this.gameLoop();
            }
            
            resizeCanvas() {
                this.canvas.width = this.canvas.offsetWidth;
                this.canvas.height = this.canvas.offsetHeight;
            }
            
            setupEvents() {
                document.addEventListener('keydown', (e) => this.keys[e.code] = true);
                document.addEventListener('keyup', (e) => this.keys[e.code] = false);
                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.mousePos.x = e.clientX - rect.left;
                    this.mousePos.y = e.clientY - rect.top;
                });
                this.canvas.addEventListener('mousedown', () => { this.isMouseDown = true; });
                this.canvas.addEventListener('mouseup', () => { this.isMouseDown = false; });
                this.canvas.addEventListener('mouseleave', () => { this.isMouseDown = false; }); // Stop firing if mouse leaves canvas
                window.addEventListener('resize', () => this.resizeCanvas());
            }
            
            defaultShoot(player, target, engine) {
                const dx = target.x - player.x;
                const dy = target.y - player.y;
                const dist = Math.sqrt(dx*dx + dy*dy) || 1;
                engine.projectiles.push({
                    x: player.x, y: player.y,
                    vx: (dx/dist) * 300,
                    vy: (dy/dist) * 300,
                    size: 3, color: '#00ff88', life: 2
                });
            }
            
            getEnemySpawnPosition() {
                const edge = Math.floor(Math.random() * 4);
                let x, y;
                const offset = 30;
                switch(edge) {
                    case 0: x = Math.random() * this.canvas.width; y = -offset; break;
                    case 1: x = this.canvas.width + offset; y = Math.random() * this.canvas.height; break;
                    case 2: x = Math.random() * this.canvas.width; y = this.canvas.height + offset; break;
                    case 3: x = -offset; y = Math.random() * this.canvas.height; break;
                }
                return { x, y };
            }

            spawnEnemy(options = {}) {
                const spawnPos = this.getEnemySpawnPosition();
                const defaults = {
                    ...spawnPos, vx: 0, vy: 0,
                    health: 30, size: 6, color: '#ff3333',
                    ai_type: 'chase' // Default AI chases player
                };
                this.enemies.push({ ...defaults, ...options });
            }
            
            handleShooting(target) {
                const now = this.gameTime;
                // Use player's fireRate, or a default of 5 if not set.
                const fireCooldown = 1 / (this.player.fireRate || 5); 
                if (now > this.lastShotTime + fireCooldown) {
                    this.weaponShoot(this.player, target, this);
                    this.lastShotTime = now;
                }
            }

            update(dt) {
                this.gameTime += dt;
                
                // Player movement
                let dx = 0, dy = 0;
                if (this.keys['KeyW'] || this.keys['ArrowUp']) dy = -1;
                if (this.keys['KeyS'] || this.keys['ArrowDown']) dy = 1;
                if (this.keys['KeyA'] || this.keys['ArrowLeft']) dx = -1;
                if (this.keys['KeyD'] || this.keys['ArrowRight']) dx = 1;

                if (dx !== 0 || dy !== 0) {
                    const mag = Math.sqrt(dx*dx + dy*dy);
                    const moveDx = dx / mag;
                    const moveDy = dy / mag;

                    this.player.lastMoveDir = { x: moveDx, y: moveDy };
                    this.player.x += moveDx * this.player.speed * dt;
                    this.player.y += moveDy * this.player.speed * dt;
                }

                this.player.x = Math.max(this.player.size, Math.min(this.canvas.width - this.player.size, this.player.x));
                this.player.y = Math.max(this.player.size, Math.min(this.canvas.height - this.player.size, this.player.y));

                // Handle shooting
                if (this.isMouseDown) {
                    this.handleShooting(this.mousePos);
                } else if (this.keys['Space']) {
                    const forwardTarget = {
                        x: this.player.x + this.player.lastMoveDir.x * 100, // Project a point 100px forward
                        y: this.player.y + this.player.lastMoveDir.y * 100
                    };
                    this.handleShooting(forwardTarget);
                }
                
                // Enemy AI
                this.enemies.forEach(enemy => {
                    // AI logic: 'chase' AI recalculates velocity towards player
                    if (enemy.ai_type === 'chase') {
                        const dx = this.player.x - enemy.x;
                        const dy = this.player.y - enemy.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist > 0) {
                            enemy.vx = (dx/dist) * this.enemySpeed;
                            enemy.vy = (dy/dist) * this.enemySpeed;
                        }
                    }
                    // Movement is applied to all enemies regardless of AI
                    enemy.x += enemy.vx * dt;
                    enemy.y += enemy.vy * dt;
                });
                
                // Projectiles
                this.projectiles.forEach(proj => {
                    proj.x += proj.vx * dt;
                    proj.y += proj.vy * dt;
                    proj.life -= dt;
                });
                
                // Particles
                this.particles.forEach(p => {
                    p.x += p.vx * dt;
                    p.y += p.vy * dt;
                    p.life -= dt;
                    p.alpha = p.life / p.maxLife;
                });
                
                this.checkCollisions();
                this.rulesUpdate(this, dt);
                
                // Cleanup
                this.projectiles = this.projectiles.filter(p => p.life > 0);
                this.particles = this.particles.filter(p => p.life > 0);
                this.enemies = this.enemies.filter(e => e.health > 0);
            }
            
            checkCollisions() {
                // Projectile-enemy
                this.projectiles.forEach(proj => {
                    this.enemies.forEach(enemy => {
                        const dx = proj.x - enemy.x;
                        const dy = proj.y - enemy.y;
                        if (Math.sqrt(dx*dx + dy*dy) < enemy.size + proj.size) {
                            enemy.health -= 25;
                            proj.life = 0;
                            this.spawnParticles(enemy.x, enemy.y, '#ff6b00', 5);
                            if (enemy.health <= 0) {
                                this.score += 10;
                                this.spawnParticles(enemy.x, enemy.y, '#ffff00', 10);
                            }
                        }
                    });
                });
                
                // Player-enemy
                this.enemies.forEach(enemy => {
                    const dx = this.player.x - enemy.x;
                    const dy = this.player.y - enemy.y;
                    if (Math.sqrt(dx*dx + dy*dy) < this.player.size + enemy.size) {
                        this.player.health -= 20;
                        this.spawnParticles(this.player.x, this.player.y, '#ff3333', 3);
                        enemy.health = 0;
                        if (this.player.health <= 0) {
                            console.log('Game Over! Score:', this.score);
                            this.player.health = 100;
                            this.score = 0;
                        }
                    }
                });
            }
            
            spawnParticles(x, y, color, count = 5) {
                for (let i = 0; i < count; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 50 + Math.random() * 100;
                    this.particles.push({
                        x, y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        color, life: 0.5, maxLife: 0.5, alpha: 1, size: 2
                    });
                }
            }
            
            render() {
                this.ctx.fillStyle = 'rgba(10, 10, 10, 0.1)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Particles
                this.particles.forEach(p => {
                    this.ctx.globalAlpha = p.alpha;
                    this.ctx.fillStyle = p.color;
                    this.ctx.beginPath();
                    this.ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    this.ctx.fill();
                });
                this.ctx.globalAlpha = 1;
                
                // Projectiles
                this.projectiles.forEach(proj => {
                    this.ctx.shadowColor = proj.color;
                    this.ctx.shadowBlur = 8;
                    this.ctx.fillStyle = proj.color;

                    if (proj.isRailgun) {
                        // Draw a thin rectangle for the railgun slug, oriented to its velocity
                        const angle = Math.atan2(proj.vy, proj.vx);
                        this.ctx.save(); // Save context state
                        this.ctx.translate(proj.x, proj.y);
                        this.ctx.rotate(angle);
                        this.ctx.fillRect(-proj.size * 2, -proj.size / 2, proj.size * 4, proj.size);
                        this.ctx.restore(); // Restore context state
                    } else {
                        this.ctx.beginPath();
                        this.ctx.arc(proj.x, proj.y, proj.size, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                    this.ctx.shadowBlur = 0;
                });
                
                // Enemies
                this.enemies.forEach(enemy => {
                    this.ctx.fillStyle = enemy.color;
                    this.ctx.shadowColor = enemy.color;
                    this.ctx.shadowBlur = 4;
                    this.ctx.beginPath();
                    this.ctx.arc(enemy.x, enemy.y, enemy.size, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.shadowBlur = 0;
                });
                
                // Player
                this.ctx.fillStyle = this.player.color;
                this.ctx.shadowColor = this.player.color;
                this.ctx.shadowBlur = 8;
                this.ctx.beginPath();
                this.ctx.arc(this.player.x, this.player.y, this.player.size, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.shadowBlur = 0;
                
                // Health bar UI
                const barWidth = 150;
                const barHeight = 10;
                const healthPercent = Math.max(0, this.player.health / 100);
                const xPos = this.canvas.width - barWidth - 20;
                const yPos = 20;
                this.ctx.fillStyle = '#333';
                this.ctx.fillRect(xPos, yPos, barWidth, barHeight);
                this.ctx.fillStyle = healthPercent > 0.5 ? '#00ff88' : healthPercent > 0.25 ? '#ffaa00' : '#ff3333';
                this.ctx.fillRect(xPos, yPos, barWidth * healthPercent, barHeight);
            }
            
            gameLoop() {
                const now = performance.now();
                const dt = (now - (this.lastTime || now)) / 1000;
                this.lastTime = now;
                
                this.update(dt);
                this.render();
                this.updateStats();
                
                this.frameCount++;
                requestAnimationFrame(() => this.gameLoop());
            }
            
            updateStats() {
                const now = performance.now();
                if (now - this.lastFpsUpdate > 1000) {
                    document.getElementById('fps').textContent = Math.round(this.frameCount * 1000 / (now - this.lastFpsUpdate));
                    this.frameCount = 0;
                    this.lastFpsUpdate = now;
                }
                document.getElementById('objectCount').textContent = this.enemies.length + this.projectiles.length + this.particles.length + 1;
                document.getElementById('score').textContent = this.score;
            }
        }
        
        // --- MOD SYSTEM ---

        function selectPreset(modType, presetName) {
            const textarea = document.getElementById(`${modType}Code`);
            const presets = game.allPresets[modType];
            if (presets && presets[presetName]) {
                textarea.value = presets[presetName];
            }
        }

        function applyMod(modType) {
            const code = document.getElementById(`${modType}Code`).value;
            try {
                const functionBody = code.substring(code.indexOf('{') + 1, code.lastIndexOf('}'));
                
                switch(modType) {
                    case 'weapon':
                        game.weaponShoot = new Function('player', 'target', 'engine', functionBody);
                        break;
                    case 'rule':
                        game.rulesUpdate = new Function('engine', 'dt', functionBody);
                        break;
                    case 'player':
                        const modFunc = new Function('player', functionBody);
                        modFunc(game.player);
                        break;
                }
                console.log(`${modType.charAt(0).toUpperCase() + modType.slice(1)} mod applied!`);
            } catch (e) {
                alert(`Error in ${modType} code: ` + e.message);
            }
        }

        function savePreset(modType) {
            const nameInput = document.getElementById(`${modType}PresetName`);
            const presetName = nameInput.value.trim();
            const code = document.getElementById(`${modType}Code`).value;

            if (!presetName) {
                alert('Please enter a name for your preset.');
                return;
            }
            if (presetName === 'default') {
                alert('Cannot overwrite the "default" preset.');
                return;
            }

            const storageKey = `sovereign_${modType}_mods`;
            let customMods = JSON.parse(localStorage.getItem(storageKey)) || {};
            customMods[presetName] = code;
            localStorage.setItem(storageKey, JSON.stringify(customMods));

            alert(`Preset "${presetName}" saved!`);
            nameInput.value = '';
            initializeModSystem();
            selectPreset(modType, presetName);
        }

        function executeHack() {
            const code = document.getElementById('hackCode').value;
            if (!code) return; // Don't run empty code
            try {
                // The code is executed with 'game', 'player', and 'engine' available as variables.
                const hackFunction = new Function('game', 'player', 'engine', code);
                hackFunction(game, game.player, game);
                console.log('%c⚡ Hack executed successfully!', 'color: #00ffff');
            } catch (e) {
                alert('Error in hack code: ' + e.message);
                console.error('Hack execution failed:', e);
            }
        }

        function initializeModSystem() {
            game.allPresets = { weapon: {}, rule: {}, player: {} };
            const defaultPresets = { weapon: weaponPresets, rule: rulesPresets, player: playerPresets };

            for (const modType in game.allPresets) {
                const customMods = JSON.parse(localStorage.getItem(`sovereign_${modType}_mods`)) || {};
                game.allPresets[modType] = { ...defaultPresets[modType], ...customMods };

                const selector = document.getElementById(`${modType}Selector`);
                selector.innerHTML = ''; // Clear dropdown

                for (const presetName in game.allPresets[modType]) {
                    const option = document.createElement('option');
                    option.value = presetName;
                    const isCustom = !defaultPresets[modType].hasOwnProperty(presetName);
                    option.textContent = isCustom ? `[C] ${presetName}` : presetName.charAt(0).toUpperCase() + presetName.slice(1);
                    selector.appendChild(option);
                }
            }
        }
        
        let game;
        window.onload = function() {
            game = new SovereignEngine();
            initializeModSystem();

            // Select and apply default mods on startup
            selectPreset('weapon', 'default');
            selectPreset('rule', 'default');
            selectPreset('player', 'default');
            applyMod('rule');
            applyMod('player');

            console.log(`
🚀 SOVEREIGN ENGINE LOADED
=======================
WASD/Arrows: Move
Mouse: Aim | Click/Space: Shoot
Edit code in the panel →
Every system is hackable!
`);
        };
    </script>
</body>
</html>